// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FileStruct.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_FileStruct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_FileStruct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_FileStruct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_FileStruct_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_FileStruct_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_FileStruct_2eproto_metadata_getter(int index);
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class FileRespond;
struct FileRespondDefaultTypeInternal;
extern FileRespondDefaultTypeInternal _FileRespond_default_instance_;
class FileStruct;
struct FileStructDefaultTypeInternal;
extern FileStructDefaultTypeInternal _FileStruct_default_instance_;
class FileTransfer;
struct FileTransferDefaultTypeInternal;
extern FileTransferDefaultTypeInternal _FileTransfer_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::FileInfo* Arena::CreateMaybeMessage<::FileInfo>(Arena*);
template<> ::FileRequest* Arena::CreateMaybeMessage<::FileRequest>(Arena*);
template<> ::FileRespond* Arena::CreateMaybeMessage<::FileRespond>(Arena*);
template<> ::FileStruct* Arena::CreateMaybeMessage<::FileStruct>(Arena*);
template<> ::FileTransfer* Arena::CreateMaybeMessage<::FileTransfer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TransferType : int {
  TRANSFER_TYPE_FILE_INFO = 0,
  TRANSFER_TYPE_FILE_DATA = 1,
  TRANSFER_TYPE_FILE_REQUEST = 2,
  TRANSFER_TYPE_FILE_RESPONSE = 3,
  TransferType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransferType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransferType_IsValid(int value);
constexpr TransferType TransferType_MIN = TRANSFER_TYPE_FILE_INFO;
constexpr TransferType TransferType_MAX = TRANSFER_TYPE_FILE_RESPONSE;
constexpr int TransferType_ARRAYSIZE = TransferType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferType_descriptor();
template<typename T>
inline const std::string& TransferType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferType_descriptor(), enum_t_value);
}
inline bool TransferType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransferType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferType>(
    TransferType_descriptor(), name, value);
}
enum TransferStatus : int {
  TRANSFER_STATUS_UNSPECIFIED = 0,
  TRANSFER_STATUS_PENDING = 1,
  TRANSFER_STATUS_SENDING = 2,
  TRANSFER_STATUS_COMPLETED = 3,
  TRANSFER_STATUS_FAILED = 4,
  TRANSFER_STATUS_CANCELED = 5,
  TransferStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransferStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransferStatus_IsValid(int value);
constexpr TransferStatus TransferStatus_MIN = TRANSFER_STATUS_UNSPECIFIED;
constexpr TransferStatus TransferStatus_MAX = TRANSFER_STATUS_CANCELED;
constexpr int TransferStatus_ARRAYSIZE = TransferStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferStatus_descriptor();
template<typename T>
inline const std::string& TransferStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferStatus_descriptor(), enum_t_value);
}
inline bool TransferStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransferStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferStatus>(
    TransferStatus_descriptor(), name, value);
}
// ===================================================================

class FileStruct PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileStruct) */ {
 public:
  inline FileStruct() : FileStruct(nullptr) {}
  virtual ~FileStruct();
  explicit constexpr FileStruct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileStruct(const FileStruct& from);
  FileStruct(FileStruct&& from) noexcept
    : FileStruct() {
    *this = ::std::move(from);
  }

  inline FileStruct& operator=(const FileStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileStruct& operator=(FileStruct&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileStruct& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kInfo = 1,
    kTransfer = 2,
    kRequest = 3,
    kRespond = 4,
    REQUESTTYPE_NOT_SET = 0,
  };

  static inline const FileStruct* internal_default_instance() {
    return reinterpret_cast<const FileStruct*>(
               &_FileStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FileStruct& a, FileStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(FileStruct* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileStruct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileStruct* New() const final {
    return CreateMaybeMessage<FileStruct>(nullptr);
  }

  FileStruct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileStruct>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileStruct& from);
  void MergeFrom(const FileStruct& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileStruct* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileStruct";
  }
  protected:
  explicit FileStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_FileStruct_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 5,
    kInfoFieldNumber = 1,
    kTransferFieldNumber = 2,
    kRequestFieldNumber = 3,
    kRespondFieldNumber = 4,
  };
  // string id = 5;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .FileInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::FileInfo& info() const;
  ::FileInfo* release_info();
  ::FileInfo* mutable_info();
  void set_allocated_info(::FileInfo* info);
  private:
  const ::FileInfo& _internal_info() const;
  ::FileInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::FileInfo* info);
  ::FileInfo* unsafe_arena_release_info();

  // .FileTransfer transfer = 2;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::FileTransfer& transfer() const;
  ::FileTransfer* release_transfer();
  ::FileTransfer* mutable_transfer();
  void set_allocated_transfer(::FileTransfer* transfer);
  private:
  const ::FileTransfer& _internal_transfer() const;
  ::FileTransfer* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::FileTransfer* transfer);
  ::FileTransfer* unsafe_arena_release_transfer();

  // .FileRequest request = 3;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::FileRequest& request() const;
  ::FileRequest* release_request();
  ::FileRequest* mutable_request();
  void set_allocated_request(::FileRequest* request);
  private:
  const ::FileRequest& _internal_request() const;
  ::FileRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::FileRequest* request);
  ::FileRequest* unsafe_arena_release_request();

  // .FileRespond respond = 4;
  bool has_respond() const;
  private:
  bool _internal_has_respond() const;
  public:
  void clear_respond();
  const ::FileRespond& respond() const;
  ::FileRespond* release_respond();
  ::FileRespond* mutable_respond();
  void set_allocated_respond(::FileRespond* respond);
  private:
  const ::FileRespond& _internal_respond() const;
  ::FileRespond* _internal_mutable_respond();
  public:
  void unsafe_arena_set_allocated_respond(
      ::FileRespond* respond);
  ::FileRespond* unsafe_arena_release_respond();

  void clear_requestType();
  RequestTypeCase requestType_case() const;
  // @@protoc_insertion_point(class_scope:FileStruct)
 private:
  class _Internal;
  void set_has_info();
  void set_has_transfer();
  void set_has_request();
  void set_has_respond();

  inline bool has_requestType() const;
  inline void clear_has_requestType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  union RequestTypeUnion {
    constexpr RequestTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::FileInfo* info_;
    ::FileTransfer* transfer_;
    ::FileRequest* request_;
    ::FileRespond* respond_;
  } requestType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_FileStruct_2eproto;
};
// -------------------------------------------------------------------

class FileInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  virtual ~FileInfo();
  explicit constexpr FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const final {
    return CreateMaybeMessage<FileInfo>(nullptr);
  }

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_FileStruct_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileSizeFieldNumber = 2,
  };
  // int64 fileSize = 2;
  void clear_filesize();
  ::PROTOBUF_NAMESPACE_ID::int64 filesize() const;
  void set_filesize(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_filesize() const;
  void _internal_set_filesize(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:FileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 filesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStruct_2eproto;
};
// -------------------------------------------------------------------

class FileTransfer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileTransfer) */ {
 public:
  inline FileTransfer() : FileTransfer(nullptr) {}
  virtual ~FileTransfer();
  explicit constexpr FileTransfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTransfer(const FileTransfer& from);
  FileTransfer(FileTransfer&& from) noexcept
    : FileTransfer() {
    *this = ::std::move(from);
  }

  inline FileTransfer& operator=(const FileTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransfer& operator=(FileTransfer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileTransfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransfer* internal_default_instance() {
    return reinterpret_cast<const FileTransfer*>(
               &_FileTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileTransfer& a, FileTransfer& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTransfer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransfer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileTransfer* New() const final {
    return CreateMaybeMessage<FileTransfer>(nullptr);
  }

  FileTransfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileTransfer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileTransfer& from);
  void MergeFrom(const FileTransfer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransfer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileTransfer";
  }
  protected:
  explicit FileTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_FileStruct_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kDataStartFieldNumber = 2,
    kDataEndFieldNumber = 3,
    kStatusFieldNumber = 5,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 dataStart = 2;
  void clear_datastart();
  ::PROTOBUF_NAMESPACE_ID::int64 datastart() const;
  void set_datastart(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_datastart() const;
  void _internal_set_datastart(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 dataEnd = 3;
  void clear_dataend();
  ::PROTOBUF_NAMESPACE_ID::int64 dataend() const;
  void set_dataend(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dataend() const;
  void _internal_set_dataend(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .TransferStatus status = 5;
  void clear_status();
  ::TransferStatus status() const;
  void set_status(::TransferStatus value);
  private:
  ::TransferStatus _internal_status() const;
  void _internal_set_status(::TransferStatus value);
  public:

  // @@protoc_insertion_point(class_scope:FileTransfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int64 datastart_;
  ::PROTOBUF_NAMESPACE_ID::int64 dataend_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStruct_2eproto;
};
// -------------------------------------------------------------------

class FileRespond PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileRespond) */ {
 public:
  inline FileRespond() : FileRespond(nullptr) {}
  virtual ~FileRespond();
  explicit constexpr FileRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRespond(const FileRespond& from);
  FileRespond(FileRespond&& from) noexcept
    : FileRespond() {
    *this = ::std::move(from);
  }

  inline FileRespond& operator=(const FileRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRespond& operator=(FileRespond&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRespond* internal_default_instance() {
    return reinterpret_cast<const FileRespond*>(
               &_FileRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileRespond& a, FileRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRespond* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileRespond* New() const final {
    return CreateMaybeMessage<FileRespond>(nullptr);
  }

  FileRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileRespond>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileRespond& from);
  void MergeFrom(const FileRespond& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRespond* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileRespond";
  }
  protected:
  explicit FileRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_FileStruct_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kResultFieldNumber = 1,
    kTypeFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // .TransferType type = 3;
  void clear_type();
  ::TransferType type() const;
  void set_type(::TransferType value);
  private:
  ::TransferType _internal_type() const;
  void _internal_set_type(::TransferType value);
  public:

  // .TransferStatus status = 4;
  void clear_status();
  ::TransferStatus status() const;
  void set_status(::TransferStatus value);
  private:
  ::TransferStatus _internal_status() const;
  void _internal_set_status(::TransferStatus value);
  public:

  // @@protoc_insertion_point(class_scope:FileRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool result_;
  int type_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStruct_2eproto;
};
// -------------------------------------------------------------------

class FileRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileRequest) */ {
 public:
  inline FileRequest() : FileRequest(nullptr) {}
  virtual ~FileRequest();
  explicit constexpr FileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRequest(const FileRequest& from);
  FileRequest(FileRequest&& from) noexcept
    : FileRequest() {
    *this = ::std::move(from);
  }

  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRequest* internal_default_instance() {
    return reinterpret_cast<const FileRequest*>(
               &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileRequest& a, FileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileRequest* New() const final {
    return CreateMaybeMessage<FileRequest>(nullptr);
  }

  FileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileRequest& from);
  void MergeFrom(const FileRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileRequest";
  }
  protected:
  explicit FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_FileStruct_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kChunkStartFieldNumber = 2,
    kChunkEndFieldNumber = 3,
    kStatusFieldNumber = 5,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 chunkStart = 2;
  void clear_chunkstart();
  ::PROTOBUF_NAMESPACE_ID::int32 chunkstart() const;
  void set_chunkstart(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_chunkstart() const;
  void _internal_set_chunkstart(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 chunkEnd = 3;
  void clear_chunkend();
  ::PROTOBUF_NAMESPACE_ID::int32 chunkend() const;
  void set_chunkend(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_chunkend() const;
  void _internal_set_chunkend(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .TransferStatus status = 5;
  void clear_status();
  ::TransferStatus status() const;
  void set_status(::TransferStatus value);
  private:
  ::TransferStatus _internal_status() const;
  void _internal_set_status(::TransferStatus value);
  public:

  // @@protoc_insertion_point(class_scope:FileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 chunkstart_;
  ::PROTOBUF_NAMESPACE_ID::int32 chunkend_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStruct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileStruct

// .FileInfo info = 1;
inline bool FileStruct::_internal_has_info() const {
  return requestType_case() == kInfo;
}
inline bool FileStruct::has_info() const {
  return _internal_has_info();
}
inline void FileStruct::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void FileStruct::clear_info() {
  if (_internal_has_info()) {
    if (GetArena() == nullptr) {
      delete requestType_.info_;
    }
    clear_has_requestType();
  }
}
inline ::FileInfo* FileStruct::release_info() {
  // @@protoc_insertion_point(field_release:FileStruct.info)
  if (_internal_has_info()) {
    clear_has_requestType();
      ::FileInfo* temp = requestType_.info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    requestType_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileInfo& FileStruct::_internal_info() const {
  return _internal_has_info()
      ? *requestType_.info_
      : reinterpret_cast< ::FileInfo&>(::_FileInfo_default_instance_);
}
inline const ::FileInfo& FileStruct::info() const {
  // @@protoc_insertion_point(field_get:FileStruct.info)
  return _internal_info();
}
inline ::FileInfo* FileStruct::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FileStruct.info)
  if (_internal_has_info()) {
    clear_has_requestType();
    ::FileInfo* temp = requestType_.info_;
    requestType_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileStruct::unsafe_arena_set_allocated_info(::FileInfo* info) {
  clear_requestType();
  if (info) {
    set_has_info();
    requestType_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileStruct.info)
}
inline ::FileInfo* FileStruct::_internal_mutable_info() {
  if (!_internal_has_info()) {
    clear_requestType();
    set_has_info();
    requestType_.info_ = CreateMaybeMessage< ::FileInfo >(GetArena());
  }
  return requestType_.info_;
}
inline ::FileInfo* FileStruct::mutable_info() {
  // @@protoc_insertion_point(field_mutable:FileStruct.info)
  return _internal_mutable_info();
}

// .FileTransfer transfer = 2;
inline bool FileStruct::_internal_has_transfer() const {
  return requestType_case() == kTransfer;
}
inline bool FileStruct::has_transfer() const {
  return _internal_has_transfer();
}
inline void FileStruct::set_has_transfer() {
  _oneof_case_[0] = kTransfer;
}
inline void FileStruct::clear_transfer() {
  if (_internal_has_transfer()) {
    if (GetArena() == nullptr) {
      delete requestType_.transfer_;
    }
    clear_has_requestType();
  }
}
inline ::FileTransfer* FileStruct::release_transfer() {
  // @@protoc_insertion_point(field_release:FileStruct.transfer)
  if (_internal_has_transfer()) {
    clear_has_requestType();
      ::FileTransfer* temp = requestType_.transfer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    requestType_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileTransfer& FileStruct::_internal_transfer() const {
  return _internal_has_transfer()
      ? *requestType_.transfer_
      : reinterpret_cast< ::FileTransfer&>(::_FileTransfer_default_instance_);
}
inline const ::FileTransfer& FileStruct::transfer() const {
  // @@protoc_insertion_point(field_get:FileStruct.transfer)
  return _internal_transfer();
}
inline ::FileTransfer* FileStruct::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FileStruct.transfer)
  if (_internal_has_transfer()) {
    clear_has_requestType();
    ::FileTransfer* temp = requestType_.transfer_;
    requestType_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileStruct::unsafe_arena_set_allocated_transfer(::FileTransfer* transfer) {
  clear_requestType();
  if (transfer) {
    set_has_transfer();
    requestType_.transfer_ = transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileStruct.transfer)
}
inline ::FileTransfer* FileStruct::_internal_mutable_transfer() {
  if (!_internal_has_transfer()) {
    clear_requestType();
    set_has_transfer();
    requestType_.transfer_ = CreateMaybeMessage< ::FileTransfer >(GetArena());
  }
  return requestType_.transfer_;
}
inline ::FileTransfer* FileStruct::mutable_transfer() {
  // @@protoc_insertion_point(field_mutable:FileStruct.transfer)
  return _internal_mutable_transfer();
}

// .FileRequest request = 3;
inline bool FileStruct::_internal_has_request() const {
  return requestType_case() == kRequest;
}
inline bool FileStruct::has_request() const {
  return _internal_has_request();
}
inline void FileStruct::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void FileStruct::clear_request() {
  if (_internal_has_request()) {
    if (GetArena() == nullptr) {
      delete requestType_.request_;
    }
    clear_has_requestType();
  }
}
inline ::FileRequest* FileStruct::release_request() {
  // @@protoc_insertion_point(field_release:FileStruct.request)
  if (_internal_has_request()) {
    clear_has_requestType();
      ::FileRequest* temp = requestType_.request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    requestType_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileRequest& FileStruct::_internal_request() const {
  return _internal_has_request()
      ? *requestType_.request_
      : reinterpret_cast< ::FileRequest&>(::_FileRequest_default_instance_);
}
inline const ::FileRequest& FileStruct::request() const {
  // @@protoc_insertion_point(field_get:FileStruct.request)
  return _internal_request();
}
inline ::FileRequest* FileStruct::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FileStruct.request)
  if (_internal_has_request()) {
    clear_has_requestType();
    ::FileRequest* temp = requestType_.request_;
    requestType_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileStruct::unsafe_arena_set_allocated_request(::FileRequest* request) {
  clear_requestType();
  if (request) {
    set_has_request();
    requestType_.request_ = request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileStruct.request)
}
inline ::FileRequest* FileStruct::_internal_mutable_request() {
  if (!_internal_has_request()) {
    clear_requestType();
    set_has_request();
    requestType_.request_ = CreateMaybeMessage< ::FileRequest >(GetArena());
  }
  return requestType_.request_;
}
inline ::FileRequest* FileStruct::mutable_request() {
  // @@protoc_insertion_point(field_mutable:FileStruct.request)
  return _internal_mutable_request();
}

// .FileRespond respond = 4;
inline bool FileStruct::_internal_has_respond() const {
  return requestType_case() == kRespond;
}
inline bool FileStruct::has_respond() const {
  return _internal_has_respond();
}
inline void FileStruct::set_has_respond() {
  _oneof_case_[0] = kRespond;
}
inline void FileStruct::clear_respond() {
  if (_internal_has_respond()) {
    if (GetArena() == nullptr) {
      delete requestType_.respond_;
    }
    clear_has_requestType();
  }
}
inline ::FileRespond* FileStruct::release_respond() {
  // @@protoc_insertion_point(field_release:FileStruct.respond)
  if (_internal_has_respond()) {
    clear_has_requestType();
      ::FileRespond* temp = requestType_.respond_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    requestType_.respond_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileRespond& FileStruct::_internal_respond() const {
  return _internal_has_respond()
      ? *requestType_.respond_
      : reinterpret_cast< ::FileRespond&>(::_FileRespond_default_instance_);
}
inline const ::FileRespond& FileStruct::respond() const {
  // @@protoc_insertion_point(field_get:FileStruct.respond)
  return _internal_respond();
}
inline ::FileRespond* FileStruct::unsafe_arena_release_respond() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FileStruct.respond)
  if (_internal_has_respond()) {
    clear_has_requestType();
    ::FileRespond* temp = requestType_.respond_;
    requestType_.respond_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileStruct::unsafe_arena_set_allocated_respond(::FileRespond* respond) {
  clear_requestType();
  if (respond) {
    set_has_respond();
    requestType_.respond_ = respond;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileStruct.respond)
}
inline ::FileRespond* FileStruct::_internal_mutable_respond() {
  if (!_internal_has_respond()) {
    clear_requestType();
    set_has_respond();
    requestType_.respond_ = CreateMaybeMessage< ::FileRespond >(GetArena());
  }
  return requestType_.respond_;
}
inline ::FileRespond* FileStruct::mutable_respond() {
  // @@protoc_insertion_point(field_mutable:FileStruct.respond)
  return _internal_mutable_respond();
}

// string id = 5;
inline void FileStruct::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& FileStruct::id() const {
  // @@protoc_insertion_point(field_get:FileStruct.id)
  return _internal_id();
}
inline void FileStruct::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:FileStruct.id)
}
inline std::string* FileStruct::mutable_id() {
  // @@protoc_insertion_point(field_mutable:FileStruct.id)
  return _internal_mutable_id();
}
inline const std::string& FileStruct::_internal_id() const {
  return id_.Get();
}
inline void FileStruct::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FileStruct::set_id(std::string&& value) {
  
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:FileStruct.id)
}
inline void FileStruct::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:FileStruct.id)
}
inline void FileStruct::set_id(const char* value,
    size_t size) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:FileStruct.id)
}
inline std::string* FileStruct::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FileStruct::release_id() {
  // @@protoc_insertion_point(field_release:FileStruct.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileStruct::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:FileStruct.id)
}

inline bool FileStruct::has_requestType() const {
  return requestType_case() != REQUESTTYPE_NOT_SET;
}
inline void FileStruct::clear_has_requestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline FileStruct::RequestTypeCase FileStruct::requestType_case() const {
  return FileStruct::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileInfo

// int64 fileSize = 2;
inline void FileInfo::clear_filesize() {
  filesize_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileInfo::_internal_filesize() const {
  return filesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileInfo::filesize() const {
  // @@protoc_insertion_point(field_get:FileInfo.fileSize)
  return _internal_filesize();
}
inline void FileInfo::_internal_set_filesize(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  filesize_ = value;
}
inline void FileInfo::set_filesize(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:FileInfo.fileSize)
}

// -------------------------------------------------------------------

// FileTransfer

// int64 dataStart = 2;
inline void FileTransfer::clear_datastart() {
  datastart_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileTransfer::_internal_datastart() const {
  return datastart_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileTransfer::datastart() const {
  // @@protoc_insertion_point(field_get:FileTransfer.dataStart)
  return _internal_datastart();
}
inline void FileTransfer::_internal_set_datastart(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  datastart_ = value;
}
inline void FileTransfer::set_datastart(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_datastart(value);
  // @@protoc_insertion_point(field_set:FileTransfer.dataStart)
}

// int64 dataEnd = 3;
inline void FileTransfer::clear_dataend() {
  dataend_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileTransfer::_internal_dataend() const {
  return dataend_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileTransfer::dataend() const {
  // @@protoc_insertion_point(field_get:FileTransfer.dataEnd)
  return _internal_dataend();
}
inline void FileTransfer::_internal_set_dataend(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  dataend_ = value;
}
inline void FileTransfer::set_dataend(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dataend(value);
  // @@protoc_insertion_point(field_set:FileTransfer.dataEnd)
}

// bytes data = 4;
inline void FileTransfer::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& FileTransfer::data() const {
  // @@protoc_insertion_point(field_get:FileTransfer.data)
  return _internal_data();
}
inline void FileTransfer::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:FileTransfer.data)
}
inline std::string* FileTransfer::mutable_data() {
  // @@protoc_insertion_point(field_mutable:FileTransfer.data)
  return _internal_mutable_data();
}
inline const std::string& FileTransfer::_internal_data() const {
  return data_.Get();
}
inline void FileTransfer::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FileTransfer::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:FileTransfer.data)
}
inline void FileTransfer::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:FileTransfer.data)
}
inline void FileTransfer::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:FileTransfer.data)
}
inline std::string* FileTransfer::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FileTransfer::release_data() {
  // @@protoc_insertion_point(field_release:FileTransfer.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileTransfer::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:FileTransfer.data)
}

// .TransferStatus status = 5;
inline void FileTransfer::clear_status() {
  status_ = 0;
}
inline ::TransferStatus FileTransfer::_internal_status() const {
  return static_cast< ::TransferStatus >(status_);
}
inline ::TransferStatus FileTransfer::status() const {
  // @@protoc_insertion_point(field_get:FileTransfer.status)
  return _internal_status();
}
inline void FileTransfer::_internal_set_status(::TransferStatus value) {
  
  status_ = value;
}
inline void FileTransfer::set_status(::TransferStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:FileTransfer.status)
}

// -------------------------------------------------------------------

// FileRespond

// bool result = 1;
inline void FileRespond::clear_result() {
  result_ = false;
}
inline bool FileRespond::_internal_result() const {
  return result_;
}
inline bool FileRespond::result() const {
  // @@protoc_insertion_point(field_get:FileRespond.result)
  return _internal_result();
}
inline void FileRespond::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void FileRespond::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:FileRespond.result)
}

// string msg = 2;
inline void FileRespond::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& FileRespond::msg() const {
  // @@protoc_insertion_point(field_get:FileRespond.msg)
  return _internal_msg();
}
inline void FileRespond::set_msg(const std::string& value) {
  _internal_set_msg(value);
  // @@protoc_insertion_point(field_set:FileRespond.msg)
}
inline std::string* FileRespond::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:FileRespond.msg)
  return _internal_mutable_msg();
}
inline const std::string& FileRespond::_internal_msg() const {
  return msg_.Get();
}
inline void FileRespond::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FileRespond::set_msg(std::string&& value) {
  
  msg_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:FileRespond.msg)
}
inline void FileRespond::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:FileRespond.msg)
}
inline void FileRespond::set_msg(const char* value,
    size_t size) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:FileRespond.msg)
}
inline std::string* FileRespond::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FileRespond::release_msg() {
  // @@protoc_insertion_point(field_release:FileRespond.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileRespond::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:FileRespond.msg)
}

// .TransferType type = 3;
inline void FileRespond::clear_type() {
  type_ = 0;
}
inline ::TransferType FileRespond::_internal_type() const {
  return static_cast< ::TransferType >(type_);
}
inline ::TransferType FileRespond::type() const {
  // @@protoc_insertion_point(field_get:FileRespond.type)
  return _internal_type();
}
inline void FileRespond::_internal_set_type(::TransferType value) {
  
  type_ = value;
}
inline void FileRespond::set_type(::TransferType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:FileRespond.type)
}

// .TransferStatus status = 4;
inline void FileRespond::clear_status() {
  status_ = 0;
}
inline ::TransferStatus FileRespond::_internal_status() const {
  return static_cast< ::TransferStatus >(status_);
}
inline ::TransferStatus FileRespond::status() const {
  // @@protoc_insertion_point(field_get:FileRespond.status)
  return _internal_status();
}
inline void FileRespond::_internal_set_status(::TransferStatus value) {
  
  status_ = value;
}
inline void FileRespond::set_status(::TransferStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:FileRespond.status)
}

// -------------------------------------------------------------------

// FileRequest

// int32 chunkStart = 2;
inline void FileRequest::clear_chunkstart() {
  chunkstart_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileRequest::_internal_chunkstart() const {
  return chunkstart_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileRequest::chunkstart() const {
  // @@protoc_insertion_point(field_get:FileRequest.chunkStart)
  return _internal_chunkstart();
}
inline void FileRequest::_internal_set_chunkstart(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  chunkstart_ = value;
}
inline void FileRequest::set_chunkstart(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_chunkstart(value);
  // @@protoc_insertion_point(field_set:FileRequest.chunkStart)
}

// int32 chunkEnd = 3;
inline void FileRequest::clear_chunkend() {
  chunkend_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileRequest::_internal_chunkend() const {
  return chunkend_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileRequest::chunkend() const {
  // @@protoc_insertion_point(field_get:FileRequest.chunkEnd)
  return _internal_chunkend();
}
inline void FileRequest::_internal_set_chunkend(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  chunkend_ = value;
}
inline void FileRequest::set_chunkend(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_chunkend(value);
  // @@protoc_insertion_point(field_set:FileRequest.chunkEnd)
}

// bytes data = 4;
inline void FileRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& FileRequest::data() const {
  // @@protoc_insertion_point(field_get:FileRequest.data)
  return _internal_data();
}
inline void FileRequest::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:FileRequest.data)
}
inline std::string* FileRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable:FileRequest.data)
  return _internal_mutable_data();
}
inline const std::string& FileRequest::_internal_data() const {
  return data_.Get();
}
inline void FileRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FileRequest::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:FileRequest.data)
}
inline void FileRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:FileRequest.data)
}
inline void FileRequest::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:FileRequest.data)
}
inline std::string* FileRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FileRequest::release_data() {
  // @@protoc_insertion_point(field_release:FileRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:FileRequest.data)
}

// .TransferStatus status = 5;
inline void FileRequest::clear_status() {
  status_ = 0;
}
inline ::TransferStatus FileRequest::_internal_status() const {
  return static_cast< ::TransferStatus >(status_);
}
inline ::TransferStatus FileRequest::status() const {
  // @@protoc_insertion_point(field_get:FileRequest.status)
  return _internal_status();
}
inline void FileRequest::_internal_set_status(::TransferStatus value) {
  
  status_ = value;
}
inline void FileRequest::set_status(::TransferStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:FileRequest.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TransferType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TransferType>() {
  return ::TransferType_descriptor();
}
template <> struct is_proto_enum< ::TransferStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TransferStatus>() {
  return ::TransferStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_FileStruct_2eproto
